(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{115:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return m}));var a=t(0),i=t.n(a);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=i.a.createContext({}),p=function(e){var n=i.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},b=function(e){var n=p(e.components);return i.a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},u=i.a.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),b=p(t),u=a,m=b["".concat(o,".").concat(u)]||b[u]||d[u]||r;return t?i.a.createElement(m,l(l({ref:n},c),{},{components:t})):i.a.createElement(m,l({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,o=new Array(r);o[0]=u;var l={};for(var s in n)hasOwnProperty.call(n,s)&&(l[s]=n[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<r;c++)o[c]=t[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},160:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/sound-sinewave-852e6c6a751de54a079f42afd2f270a1.png"},161:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/sound-sinewave-cycles-2c4fc7ee671d8fba7ee1cd002fe2528e.png"},162:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/sound-sinewave-samples-836e8f3c7a1ca1c2e71bd0fd27d6a69c.png"},163:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/sound-noclip-8a2e991ca0e77b1449e3d2bf8beba436.png"},164:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/sound-clip-f35397ef050673b7eb36adc61136cec1.png"},165:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/sound-square-7cdd1f0f52c1b76a5c3d5750fc41784c.png"},166:function(e,n,t){"use strict";t.r(n),n.default=t.p+"assets/images/sound-saw-7fe832f1b48f8ea0e78fc130aca71dc4.png"},78:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return o})),t.d(n,"metadata",(function(){return l})),t.d(n,"rightToc",(function(){return s})),t.d(n,"default",(function(){return p}));var a=t(2),i=t(6),r=(t(0),t(115)),o={id:"midterm",title:"Midterm Project"},l={unversionedId:"assignments/midterm",id:"assignments/midterm",isDocsHomePage:!1,title:"Midterm Project",description:"* You are expected to work as a team of two.",source:"@site/docs\\assignments\\midterm.md",slug:"/assignments/midterm",permalink:"/cs220-sp21/docs/assignments/midterm",version:"current"},s=[{value:"Getting started",id:"getting-started",children:[]},{value:"What sound is",id:"what-sound-is",children:[{value:"Complex audio waveforms",id:"complex-audio-waveforms",children:[]},{value:"Digital sound",id:"digital-sound",children:[]},{value:"Mixing digital audio signals, clipping",id:"mixing-digital-audio-signals-clipping",children:[]},{value:"Stereo sound, WAVE files",id:"stereo-sound-wave-files",children:[]}]},{value:"I/O routines",id:"io-routines",children:[{value:"<code>fatal_error</code> function",id:"fatal_error-function",children:[]},{value:"Binary I/O routines",id:"binary-io-routines",children:[]}]},{value:"Wave routines",id:"wave-routines",children:[{value:"<code>wave.h</code>",id:"waveh",children:[]},{value:"<code>read_wave_header</code>, <code>write_wave_header</code>",id:"read_wave_header-write_wave_header",children:[]},{value:"Rendering tones",id:"rendering-tones",children:[]},{value:"Hints on how to render waveforms",id:"hints-on-how-to-render-waveforms",children:[]},{value:"Rendering is additive!",id:"rendering-is-additive",children:[]}]},{value:"The <code>render_tone</code> program",id:"the-render_tone-program",children:[{value:"Invocation of <code>render_tone</code>",id:"invocation-of-render_tone",children:[]},{value:"<code>render_tone</code> examples",id:"render_tone-examples",children:[]},{value:"<code>render_tone</code> approach",id:"render_tone-approach",children:[]}]},{value:"The <code>render_song</code> program",id:"the-render_song-program",children:[{value:"Invocation, input data format",id:"invocation-input-data-format",children:[]},{value:"<code>render_song</code> example",id:"render_song-example",children:[]},{value:"Important requirement",id:"important-requirement",children:[]},{value:"<code>render_song</code> approach",id:"render_song-approach",children:[]}]},{value:"The <code>render_echo</code> program",id:"the-render_echo-program",children:[{value:"Invocation",id:"invocation",children:[]},{value:"Generating an echo",id:"generating-an-echo",children:[]},{value:"Examples",id:"examples",children:[]},{value:"<code>render_echo</code> approach",id:"render_echo-approach",children:[]}]},{value:"Testing",id:"testing",children:[]},{value:"Tips",id:"tips",children:[]},{value:"Packaging requirements",id:"packaging-requirements",children:[]}],c={rightToc:s};function p(e){var n=e.components,o=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,o,{components:n,mdxType:"MDXLayout"}),Object(r.b)("div",{className:"admonition admonition-caution alert alert--warning"},Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(r.b)("h5",{parentName:"div"},Object(r.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(r.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"}),Object(r.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"})))),"caution")),Object(r.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(r.b)("ul",{parentName:"div"},Object(r.b)("li",{parentName:"ul"},"You are expected to work as a team of two."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Due: Tuesday ",Object(r.b)("strong",{parentName:"strong"},"March 25th")," at 11pm EDT (Baltimore time).")),Object(r.b)("li",{parentName:"ul"},"No late days are allowed!")))),Object(r.b)("h1",{id:"introduction"},"Introduction"),Object(r.b)("p",null,"In this project you will implement programs to generate and transform\ndigital audio."),Object(r.b)("p",null,"This is a pair project, so you will work with one classmate.  You should\npractice pair programming where you work directly with you partner, in\nperson, to design and implement the program.  We will spend some time in\nclass working on the project, so your partner needs to be in your section."),Object(r.b)("p",null,"You will use git for version control.  ",Object(r.b)("em",{parentName:"p"},"TODO: how repo will be created,\naccessed.")),Object(r.b)("p",null,"The project is larger and more complex than the previous homework\nassignments.  You\u2019ll want to start early and make steady, incremental\nprogress towards completing the project requirements."),Object(r.b)("h2",{id:"getting-started"},"Getting started"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"TODO: details about getting started, setting up repo, etc.")),Object(r.b)("h1",{id:"sound"},"Sound"),Object(r.b)("p",null,"This section has some background about sound and how it can be represented digitally."),Object(r.b)("h2",{id:"what-sound-is"},"What sound is"),Object(r.b)("p",null,"Sound is changes in air pressure over time.  When physical objects\nvibrate, they cause oscillations in air pressure that propagate outwards\nin a wave.  A sensor such as a microphone or your ear can detect these\nchanges in pressure over time."),Object(r.b)("p",null,"The most basic type of oscillation is a sine wave, where the changes in\npressure over time are modeled by the equation"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"p")," = ",Object(r.b)("em",{parentName:"p"},"a")," \xd7 sin(",Object(r.b)("em",{parentName:"p"},"tf")," \xd7 2\u03c0)"),Object(r.b)("p",null,"where ",Object(r.b)("em",{parentName:"p"},"p")," is pressure, ",Object(r.b)("em",{parentName:"p"},"t")," is time, ",Object(r.b)("em",{parentName:"p"},"f")," is frequency, and ",Object(r.b)("em",{parentName:"p"},"a")," is\namplitude.  Because the sine function yields both positive and negative\nvalues, the resulting pressure values (",Object(r.b)("em",{parentName:"p"},"p"),") can be both positive and\nnegative.  The pressure values represent the instantaneous air pressure\nrelative to the overall average air pressure."),Object(r.b)("p",null,"Plotted with time on the x-axis and pressure on the y-axis, a sine wave\nlooks like this:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Sine wave",src:t(160).default})),Object(r.b)("p",null,"A ",Object(r.b)("em",{parentName:"p"},"cycle")," consists of one full oscillation with both positive and negative peaks:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Sine wave cycle",src:t(161).default})),Object(r.b)("p",null,"When the frequency increases, the cycles become shorter, so there are more\ncycles per unit of time.  The standard measurement of frequency, the Hertz\n(abbreviated Hz), is defined as one cycle per second.  Sound waves have\nfrequencies that range from the low tens of Hz to tens of thousands of Hz.\nWe perceive sounds with higher frequencies as being higher-pitched."),Object(r.b)("p",null,"Here is what one second of a 440 Hz sine wave sounds like:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/a440.wav",type:"audio/wav"})),Object(r.b)("div",null),Object(r.b)("h3",{id:"complex-audio-waveforms"},"Complex audio waveforms"),Object(r.b)("p",null,"Obviously real sounds are much more complex than just plain sine waves.\nIn general, any sound can be represented by the ",Object(r.b)("em",{parentName:"p"},"sum")," of sine waves of\nvarying frequencies and amplitudes.  Here is one second of a 440 Hz sine\nwave mixed with a 587.33 Hz sine wave:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/a440_third.wav",type:"audio/wav"})),Object(r.b)("div",null),Object(r.b)("p",null,"At a physical level, the air pressure changes as the ",Object(r.b)("em",{parentName:"p"},"sum")," of the pressure\nchanges induced by all of the sine waves being generated.  Humans can\neffectively hear multiple tones at the same time, deconstructing the\nadded sine waves into the constituent frequencies.  The example you just\nheard (440 Hz and 587.33 Hz) is two tones separated by a ",Object(r.b)("em",{parentName:"p"},"major third"),",\nan important frequency interval in western music."),Object(r.b)("h3",{id:"digital-sound"},"Digital sound"),Object(r.b)("p",null,"There are a variety of ways to represent sound using a computer.\nThe most straightforward way is using linear ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Pulse-code_modulation"}),"pulse code\nmodulation"),",\nwhere sound is represented as a sequence of ",Object(r.b)("em",{parentName:"p"},"samples"),", each sample\nrepresenting air pressure at a moment in time.  The ",Object(r.b)("em",{parentName:"p"},"sampling frequency"),"\ndetermines how many (evenly spaced) samples there are per unit of time.\nCD quality audio, a common PCM format, uses signed 16 bit samples\n(ranging from -32,768 to 32,767) and a sampling frequency of 44.1 KHz\n(44,100 samples per second.)  In C, the ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t")," data type (defined in\nthe ",Object(r.b)("inlineCode",{parentName:"p"},"<stdint.h>")," header file) matches the range of sample data values\nfor CD quality audio.  So, an array of ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t")," elements can represent\nCD quality audio: each 44,100 elements represents one second of (monaural) audio."),Object(r.b)("p",null,"To make this idea explicit, let's say that the sound we want to represent\nis a sine wave with an amplitude of 0.1 and a frequency of 440 Hz.\nWe'll consider amplitude as being relative to the loudest possible sound,\ndefined as 1.0, so a signal with an amplitude of 0.1 has positive and\nnegative peaks that are 10% as large as the loudest possible signal.\nWith a sampling frequency of 44.1 KHz, each cycle of our 440 Hz audio\nsignal will be represented by about 100 samples (really 100.22727...).  The values of the\nindividual samples will vary between (approximately) -3,276 and 3,276.\nLet's say the audio data is in an array of ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t")," elements called\n",Object(r.b)("inlineCode",{parentName:"p"},"sound"),".  Here is a diagram showing several points on the first cycle\nof the signal, their values, and which array elements they would be\nstored in:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Sine wave with samples",src:t(162).default})),Object(r.b)("p",null,"As long as the number of bits per sample is reasonably large, and the\nsampling frequency is reasonably high, PCM can represent audio with a\nhigh degree of fidelity to the original sound."),Object(r.b)("h3",{id:"mixing-digital-audio-signals-clipping"},"Mixing digital audio signals, clipping"),Object(r.b)("p",null,"Because sound waves interact additively, you can combine two digital\naudio signals by simply ",Object(r.b)("em",{parentName:"p"},"adding")," their respective sample values."),Object(r.b)("p",null,"A potential problem that can arise when adding sample values is that\nthe sum might exceed the maximum positive or negative sample values: for\nexample, 32,767 and -32,768 for 16 bit signed samples.  If this happens,\nwe can't really fully represent the resulting combined signal.  ",Object(r.b)("em",{parentName:"p"},"Clipping"),"\nis a phenomenon that results from such overflows, in particular, when we\nuse ",Object(r.b)("em",{parentName:"p"},"saturating")," addition such that sums greater than the maximum possible\nvalue or less than the minimum possible value (e.g., 32,767/-32,768)\nare ",Object(r.b)("em",{parentName:"p"},"clamped")," at the maximum or minimum."),Object(r.b)("p",null,"For example, here is an audio signal where the amplitude exceeds the\nrange that can be represented, with the minimum and maximum sample values\nshown as light blue dashed lines:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Audio signal before clipping",src:t(163).default})),Object(r.b)("p",null,"Clipping will change the waveform to the following:"),Object(r.b)("p",null,Object(r.b)("img",{alt:"Audio signal after clipping",src:t(164).default})),Object(r.b)("p",null,"Humans perceive clipping as distortion of the original signals.\nClipping can be avoided by making sure that audio signals being mixed\nhave relatively small amplitudes, so that the sum of their sample values\nnever exceeds the range of representable sample values."),Object(r.b)("h3",{id:"stereo-sound-wave-files"},"Stereo sound, WAVE files"),Object(r.b)("p",null,"Most sound recordings are ",Object(r.b)("em",{parentName:"p"},"stereo")," meaning that there are separate\nleft and right audio channels.  A common way to represent stereo audio\nis to consider the even-numbered samples (0 being the first sample) as\nbelonging to the left channel, and the odd-numbered samples as belonging\nto the right channel."),Object(r.b)("p",null,"The ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"http://soundfile.sapp.org/doc/WaveFormat/"}),"WAVE file format")," is a\ncommon file format for digital audio.  Although a variety of encodings\nare possible in WAVE files, they are most commonly used for linear PCM\naudio data.  Wave files represent stereo PCM data using the scheme just\ndescribed (samples 0, 2, 4, etc. belong to the left channel, samples 1,\n3, 5, etc. belong to the right channel.)"),Object(r.b)("p",null,"In this project you will write programs to read and write audio data in\nthe WAVE format.  The good news is that WAVE files are pretty simple:\nthey consist of a ",Object(r.b)("em",{parentName:"p"},"header")," followed by raw sample data.  Digital audio\nprograms can represent sound waveforms internally using arrays with\nsample data.  To read audio data from a WAVE file, a program needs\nto read the header, and then read the raw sample data into an array.\nTo write audio data to a WAVE file, a program needs to write the header,\nand then write the raw sample data from an array."),Object(r.b)("h1",{id:"functional-requirements"},"Functional requirements"),Object(r.b)("p",null,"This section documents the functional requirements of the project."),Object(r.b)("h2",{id:"io-routines"},"I/O routines"),Object(r.b)("p",null,"This section describes the I/O routines that your programs will use to\nread binary data and write binary data.  This program module will also\ndefine an error reporting function called ",Object(r.b)("inlineCode",{parentName:"p"},"fatal_error"),".  These functions\nshould be declared in ",Object(r.b)("inlineCode",{parentName:"p"},"io.h")," and defined in ",Object(r.b)("inlineCode",{parentName:"p"},"io.c"),"."),Object(r.b)("h3",{id:"fatal_error-function"},Object(r.b)("inlineCode",{parentName:"h3"},"fatal_error")," function"),Object(r.b)("p",null,"You can start by implementing (in ",Object(r.b)("inlineCode",{parentName:"p"},"io.c"),") the ",Object(r.b)("inlineCode",{parentName:"p"},"fatal_error")," function. It\nis declared in the ",Object(r.b)("inlineCode",{parentName:"p"},"io.h")," header file, as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"void fatal_error(const char *message);\n")),Object(r.b)("p",null,"When this function is called, it should print a line of text to ",Object(r.b)("inlineCode",{parentName:"p"},"stderr")," of the form"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Error: message text\n")),Object(r.b)("p",null,'where "message text" is the string passed as the ',Object(r.b)("inlineCode",{parentName:"p"},"message")," parameter."),Object(r.b)("p",null,"The purpose of ",Object(r.b)("inlineCode",{parentName:"p"},"fatal_error")," is to immediately exit the program if an\nunrecoverable error, such as unexpected input data, is encountered.\nAlthough this is a somewhat heavy handed way of dealing with errors, it\nis simple.  We will see a more sohisticated and flexible way of reporting\nand handling runtime errors later in the course when we cover ",Object(r.b)("em",{parentName:"p"},"exceptions"),"\nin C++."),Object(r.b)("h3",{id:"binary-io-routines"},"Binary I/O routines"),Object(r.b)("p",null,"WAVE files are ",Object(r.b)("em",{parentName:"p"},"binary")," files, meaning their contents consist of arbitrary byte values."),Object(r.b)("p",null,"Furthermore, the specific type of WAVE file generated and transformed by\nthe programs you will implement in this assignment use ",Object(r.b)("em",{parentName:"p"},"little-endian"),"\nbinary data, where multi-byte values are represented as a sequence of\nbytes such that less significant bytes occur before more significant\nbytes."),Object(r.b)("p",null,"You should start your work by implementing the following binary I/O (input\nand output) functions, which are declared in the ",Object(r.b)("inlineCode",{parentName:"p"},"io.h")," header file:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"void write_byte(FILE *out, char val);\nvoid write_bytes(FILE *out, const char data[], unsigned n);\nvoid write_u16(FILE *out, uint16_t value);\nvoid write_u32(FILE *out, uint32_t value);\nvoid write_s16(FILE *out, int16_t value);\nvoid write_s16_buf(FILE *out, const int16_t buf[], unsigned n);\n\nvoid read_byte(FILE *in, char *val);\nvoid read_bytes(FILE *in, char data[], unsigned n);\nvoid read_u16(FILE *in, uint16_t *val);\nvoid read_u32(FILE *in, uint32_t *val);\nvoid read_s16(FILE *in, int16_t *val);\nvoid read_s16_buf(FILE *in, int16_t buf[], unsigned n);\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"write_byte"),", ",Object(r.b)("inlineCode",{parentName:"p"},"write_u16"),", ",Object(r.b)("inlineCode",{parentName:"p"},"write_u32"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"write_s16")," functions\nwrite a single data value of type ",Object(r.b)("inlineCode",{parentName:"p"},"char"),", ",Object(r.b)("inlineCode",{parentName:"p"},"uint16_t"),", ",Object(r.b)("inlineCode",{parentName:"p"},"uint32_t"),", or\n",Object(r.b)("inlineCode",{parentName:"p"},"int16_t")," respectively."),Object(r.b)("p",null,"Multi-byte data values (",Object(r.b)("inlineCode",{parentName:"p"},"uint16_t"),", ",Object(r.b)("inlineCode",{parentName:"p"},"uint32_t"),", ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t"),") must be written\nin ",Object(r.b)("em",{parentName:"p"},"little-endian")," format, such that less significant bytes are written\nbefore more significant bytes.  Because the ugrad machines use x86-64\nCPUs, which are little-endian, you may read and write multi-byte data\nvalues by simply treating them as a sequence of bytes.  For example,\nto write a ",Object(r.b)("inlineCode",{parentName:"p"},"uint32_t")," stored in a variable ",Object(r.b)("inlineCode",{parentName:"p"},"x")," to a ",Object(r.b)("inlineCode",{parentName:"p"},"FILE *")," file\nhandle called ",Object(r.b)("inlineCode",{parentName:"p"},"out"),", you could use the code"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"fwrite(&x, sizeof(uint32_t), 1, out);\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"write_")," functions should call ",Object(r.b)("inlineCode",{parentName:"p"},"fatal_error")," if an error occurs while writing data."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"write_bytes")," and ",Object(r.b)("inlineCode",{parentName:"p"},"write_s16_buf")," functions write a sequence of\n",Object(r.b)("inlineCode",{parentName:"p"},"char")," or ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t")," values, respectively.\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"write_bytes")," function can be implemented by a single call to\n",Object(r.b)("inlineCode",{parentName:"p"},"fwrite"),".  The ",Object(r.b)("inlineCode",{parentName:"p"},"write_s16_buf")," function can be implemented by calling\n",Object(r.b)("inlineCode",{parentName:"p"},"write_s16")," in a loop, once for each element of the argument array."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"read_byte"),", ",Object(r.b)("inlineCode",{parentName:"p"},"read_u16"),", ",Object(r.b)("inlineCode",{parentName:"p"},"read_u32"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"read_s16")," functions read a\nsingle data value of type ",Object(r.b)("inlineCode",{parentName:"p"},"char"),", ",Object(r.b)("inlineCode",{parentName:"p"},"uint16_t"),", ",Object(r.b)("inlineCode",{parentName:"p"},"uint32_t"),", or ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t"),",\nrespectively, storing the value read in a variable whose address is\npassed as a pointer parameter to the function.\nAs with the functions to write multi-byte values, the functions which\nread multi-byte data values may assume that the little-endian data values\nthey read can be directly stored in memory, because we will be running\non a little endian CPU.  For example, if you need to read a 32 bit\nunsigned value into a ",Object(r.b)("inlineCode",{parentName:"p"},"uint32_t")," variable ",Object(r.b)("inlineCode",{parentName:"p"},"x")," from a ",Object(r.b)("inlineCode",{parentName:"p"},"FILE *")," file\nhandle called ",Object(r.b)("inlineCode",{parentName:"p"},"in"),", you could use the code"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"fread(&x, sizeof(uint32_t), 1, in);\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"read_bytes")," and ",Object(r.b)("inlineCode",{parentName:"p"},"read_s16_buf")," functions read a sequence of ",Object(r.b)("inlineCode",{parentName:"p"},"char"),"\nor ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t")," values, respectively, and store them in the array passed\nas a parameter.  ",Object(r.b)("inlineCode",{parentName:"p"},"read_bytes")," can be implemented by a single call to\n",Object(r.b)("inlineCode",{parentName:"p"},"fread"),".  ",Object(r.b)("inlineCode",{parentName:"p"},"read_s16_buf")," can be implemented by calling ",Object(r.b)("inlineCode",{parentName:"p"},"read_s16")," in a\nloop, once per element."),Object(r.b)("p",null,"If any of the ",Object(r.b)("inlineCode",{parentName:"p"},"read_"),"  functions fail to read the required number of\ndata bytes, they should call the ",Object(r.b)("inlineCode",{parentName:"p"},"fatal_error")," function."),Object(r.b)("h2",{id:"wave-routines"},"Wave routines"),Object(r.b)("p",null,"This section describes functions for working with WAVE files and digital\naudio waveforms.  This module of the program consists of the header file\n",Object(r.b)("inlineCode",{parentName:"p"},"wave.h")," and the source file ",Object(r.b)("inlineCode",{parentName:"p"},"wave.c"),"."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"write_wave_header")," and ",Object(r.b)("inlineCode",{parentName:"p"},"read_wave_header")," functions require the\n",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#"}),"binary I/O functions"),", so implement those first."),Object(r.b)("h3",{id:"waveh"},Object(r.b)("inlineCode",{parentName:"h3"},"wave.h")),Object(r.b)("p",null,"The header file ",Object(r.b)("inlineCode",{parentName:"p"},"wave.h"),", as distributed in the public repo, has the following contents:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"#include <stdint.h>\n\n#define PI                 3.14159265358979323846\n#define SAMPLES_PER_SECOND 44100u\n#define NUM_CHANNELS       2u\n#define BITS_PER_SAMPLE    16u\n\n/* waveforms */\n#define SINE          0\n#define SQUARE        1\n#define SAW           2\n#define NUM_WAVEFORMS 3 /* one greater than maximum legal voice */\n\n/* timing characteristics for ADSR envelope */\n#define ATTACK_NUM_SAMPLES  441\n#define DECAY_NUM_SAMPLES   441\n#define RELEASE_NUM_SAMPLES 441\n\n// Functions for writing and reading a WAVE header.\nvoid write_wave_header(FILE *out, unsigned num_samples);\nvoid read_wave_header(FILE *in, unsigned *num_samples);\n\n// Compute appropriate gains for a stereo pan at given angle in radians.\n// Left and right channel gains are stored in the channel_gain array.\nvoid compute_pan(float angle, float channel_gain[]);\n\n// Basic full-amplitude wave generation into a mono sample buffer\nvoid generate_sine_wave(int16_t mono_buf[], unsigned num_samples, float freq_hz);\nvoid generate_square_wave(int16_t mono_buf[], unsigned num_samples, float freq_hz);\nvoid generate_saw_wave(int16_t mono_buf[], unsigned num_samples, float freq_hz);\n\n// Scale each sample in a mono sample buffer by specified factor\nvoid apply_gain(int16_t mono_buf[], unsigned num_samples, float gain);\n\n// Apply an ADSR envelope to a mono sample buffer. This should only\n// be done *after* attenuating the contents of the buffer to a reasonable\n// level, since the peak of the attack will actually increase the\n// signal's amplitude.\nvoid apply_adsr_envelope(int16_t mono_buf[], unsigned num_samples);\n\n// Mix a mono sample buffer into a stereo stream.\n// channel should be 0 (left) or 1 (right).\n// stereo_buf should be pointing to a left-channel sample.\nvoid mix_in(int16_t stereo_buf[], unsigned channel, const int16_t mono_buf[], unsigned num_samples);\n")),Object(r.b)("p",null,"The constants ",Object(r.b)("inlineCode",{parentName:"p"},"SAMPLES_PER_SECOND"),", ",Object(r.b)("inlineCode",{parentName:"p"},"NUM_CHANNELS"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"BITS_PER_SAMPLE")," define the parameters of stereo CD-quality PCM audio."),Object(r.b)("p",null,"The constant ",Object(r.b)("inlineCode",{parentName:"p"},"PI")," closely approximates the value of \u03c0."),Object(r.b)("p",null,"The constants ",Object(r.b)("inlineCode",{parentName:"p"},"SINE"),", ",Object(r.b)("inlineCode",{parentName:"p"},"SQUARE"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"SAW")," distinguish the three kinds of audio waveforms that the ",Object(r.b)("inlineCode",{parentName:"p"},"render_song")," program can generate."),Object(r.b)("p",null,"The function declarations are for functions defined in ",Object(r.b)("inlineCode",{parentName:"p"},"wave.c"),": these are described in more detail below."),Object(r.b)("h3",{id:"read_wave_header-write_wave_header"},Object(r.b)("inlineCode",{parentName:"h3"},"read_wave_header"),", ",Object(r.b)("inlineCode",{parentName:"h3"},"write_wave_header")),Object(r.b)("p",null,"Two functions called ",Object(r.b)("inlineCode",{parentName:"p"},"read_wave_header")," and ",Object(r.b)("inlineCode",{parentName:"p"},"write_wave_header")," are provided (including implementations in ",Object(r.b)("inlineCode",{parentName:"p"},"wave.c"),") which, respectively, read the header information from a WAVE file, and write header information for a WAVE file.  WAVE files are essentially just header information followed by a sequence of sample values."),Object(r.b)("p",null,"You can look at the implementation of ",Object(r.b)("inlineCode",{parentName:"p"},"read_wave_header")," and ",Object(r.b)("inlineCode",{parentName:"p"},"write_wave_header"),' to see how they use your binary I/O functions.  Note that both routines are hard-coded to support only 16 bits per sample, 44.1 KHz, stereo (two channel) WAVE files.  For our purposes, the only "interesting" value in the WAVE header is the number of ',Object(r.b)("em",{parentName:"p"},"stereo")," samples, which determines the length of the audio.  Note that a stereo sample consists of ",Object(r.b)("em",{parentName:"p"},"two")," 16-bit signed integer values, one for each channel (left and right)."),Object(r.b)("p",null,"Here is a very simple example program that calls ",Object(r.b)("inlineCode",{parentName:"p"},"read_wave_header"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),'#include <stdio.h>\n#include <stdlib.h>\n#include "io.h"\n#include "wave.h"\n\nint main(int argc, char **argv) {\n  if (argc != 2) {\n    fprintf(stderr, "Usage: %s <wave file>\\n", argv[0]);\n    exit(1);\n  }\n\n  FILE *in = fopen(argv[1], "rb");\n  if (in == NULL) {\n    fatal_error("Couldn\'t open wave file");\n  }\n\n  unsigned num_samples;\n  read_wave_header(in, &num_samples);\n  printf("Wave file has %u stereo samples\\n", num_samples);\n\n  fclose(in);\n\n  return 0;\n}\n')),Object(r.b)("p",null,"Let's say that we compile and link this program as an executable called ",Object(r.b)("inlineCode",{parentName:"p"},"readwav"),".  If we run the program on the WAVE file called ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"snd/a440.wav"}),"a440.wav")," as follows"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"./readwav a440.wav\n")),Object(r.b)("p",null,"The output will be"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Wave file has 44100 stereo samples\n")),Object(r.b)("h3",{id:"rendering-tones"},"Rendering tones"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"generate_sine_wave"),", ",Object(r.b)("inlineCode",{parentName:"p"},"generate_square_wave"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"generate_saw_wave")," functions, as declared in the initial version of ",Object(r.b)("inlineCode",{parentName:"p"},"wave.h"),", are intended to generate full-amplitude sine, square, and sawtooth waveforms with a specified frequency in a specified (mono) sample buffer."),Object(r.b)("p",null,"A square wave is a waveform where the generated sample values oscillate between maximum and minimum sample values (with respect to the amplitude), i.e."),Object(r.b)("p",null,Object(r.b)("img",{alt:"Square wave",src:t(165).default})),Object(r.b)("p",null,"Square waves are easy to generate using digital electronics, and were used frequently in early home computers and video games.  Here is a 440 Hz square wave:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/a440_sq.wav",type:"audio/wav"})),Object(r.b)("p",null,"A sawtooth wave rises steadily from the minimum sample value to the maximum sample value (with respect to amplitude) on each cycle, i.e."),Object(r.b)("p",null,Object(r.b)("img",{alt:"Sawtooth wave",src:t(166).default})),Object(r.b)("p",null,'Sawtooth waves have a more "horn-like" sound than a plain sine wave.  Here is a 440 Hz sawtooth wave:'),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/a440_saw.wav",type:"audio/wav"})),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"apply_gain")," function modifies the samples in a mono sample buffer\nby scaling them by a specified gain factor. This function is useful for\nreducing the amplitude of a full-amplitude waveform."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"apply_adsr_envelope")," function applies and ADSR (attack, sustain,\ndecay, release) envelope to the waveform in a mono sample buffer.\n",Object(r.b)("em",{parentName:"p"},"FIXME"),": explain what this means."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"mix_in")," function takes a rendered mono waveform and mixes it into one channel\nof a stereo sample buffer.  Channel 0 is the left channel, and channel 1 is the right\nchannel.  This function should ensure that sample values stay in the range\n-32,768 to 32,767, clamping them at these minimum and maximum values if necessary."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"compute_pan")," function computes appropriate gain factors for the\nleft and right channels, according to a ",Object(r.b)("em",{parentName:"p"},"pan angle")," specified in radians.\nThis function should use the following gain formulas, where ",Object(r.b)("em",{parentName:"p"},"\u03b8")," is the\npan angle, and ",Object(r.b)("em",{parentName:"p"},"L")," and ",Object(r.b)("em",{parentName:"p"},"R")," are the computed left and right channel gain factors:"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"L")," = \u221a2/2 \xd7 (cos \u03b8 + sin \u03b8)"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"R")," = \u221a2/2 \xd7 (cos \u03b8 - sin \u03b8)"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"render_song")," program will allow instrument sounds to be panned, so\nbeing able to compute appropriate channel gain factors will be important\nfor that program."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Important"),": Note that you do not need to implement any of the\n",Object(r.b)("inlineCode",{parentName:"p"},"render_")," functions exactly as described above.  You will need to\nimplement functions to generate tones, but you are free to implement\nthem in whatever way you think is appropriate.  Having said that,\nthe functions described above, if you implement them, will allow\nyou to complete the required programs in a fairly straightforward way."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Recommendation"),": Don't implement all of the audio generation functions\nat once.  Implement them as needed to support the three programs you\nwill be implementing, ",Object(r.b)("inlineCode",{parentName:"p"},"render_tone"),", ",Object(r.b)("inlineCode",{parentName:"p"},"render_song"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"render_echo"),"."),Object(r.b)("h3",{id:"hints-on-how-to-render-waveforms"},"Hints on how to render waveforms"),Object(r.b)("p",null,"Rendering sine waves is relatively straightforward, since you can use the equation"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"p")," = ",Object(r.b)("em",{parentName:"p"},"a")," \xd7 sin(",Object(r.b)("em",{parentName:"p"},"tf")," \xd7 2\u03c0)"),Object(r.b)("p",null,"more or less directly.  The main thing you'll need to think about is how\nto convert a sample number into a time value ",Object(r.b)("em",{parentName:"p"},"t"),".  (Hint: the number of\nsamples in one second of audio is defined by the ",Object(r.b)("inlineCode",{parentName:"p"},"SAMPLES_PER_SECOND"),"\nconstant.)  Also, because ",Object(r.b)("em",{parentName:"p"},"p")," will range from -1.0 to 1.0, you'll need\nto scale it appropriately to fit the range of the ",Object(r.b)("inlineCode",{parentName:"p"},"int16_t")," data type."),Object(r.b)("p",null,"You can think of square waves as being modified sine waves:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},'For any sample where a sine wave would have a non-negative value,\nthe square wave should have a "maximum" value (with respect to amplitude)'),Object(r.b)("li",{parentName:"ul"},'For any sample where a sine wave would have a negative value, the\nsquare wave should have a "minimum" value (with respect to amplitude)')),Object(r.b)("p",null,"However you generate square waves, make sure that the duty cycle is 50%,\nmeaning that the runs of maximum sample values are about the same length\nas the runs of minimum sample values."),Object(r.b)("p",null,"The sample values generated for sawtooth waves should increase linearly\nfrom the minimum to maximum throughout each cycle.  One way to implement\nthis is to take the time ",Object(r.b)("em",{parentName:"p"},"t")," of the sample, and divide it by the length\nof one cycle.  For example, let's say the frequency is 440 Hz, which\nwould make the cycle length 1/440 seconds.  If ",Object(r.b)("em",{parentName:"p"},"t")," is 4.9902 seconds,\nthen dividing ",Object(r.b)("em",{parentName:"p"},"t")," by the cycle length gives us approximately 2195.688000.\nSubtracting the ",Object(r.b)("em",{parentName:"p"},"floor")," of this value gives us 0.688.  What this means\nis that for our value of ",Object(r.b)("em",{parentName:"p"},"t")," (4.9902 seconds), the generated sawtooth\nwaveform about 2/3 of the way through the current cycle (0.688 is\nabout 2/3.)  Knowing where ",Object(r.b)("em",{parentName:"p"},"t")," is within the current cycle allows us to\ncompute an appropriate sample value."),Object(r.b)("h3",{id:"rendering-is-additive"},"Rendering is additive!"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Extremely important consideration"),": Your tone-rendering functions\nshould be ",Object(r.b)("inlineCode",{parentName:"p"},"additive"),", meaning that the waveforms that are rendered should\nbe ",Object(r.b)("em",{parentName:"p"},"added")," to whatever sample values are already present.  This is\nnecessary, for example, to allow the ",Object(r.b)("inlineCode",{parentName:"p"},"render_song"),"\nprogram to produce chords, where several frequencies are generated at\nthe same time."),Object(r.b)("p",null,"There are a couple of things you should think about in order to make this work correctly:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"You will want all sample values to be initialized to zero, prior\nto any of the ",Object(r.b)("inlineCode",{parentName:"li"},"render_")," functions being called.  This ensures that the\n`initial signal is silence."),Object(r.b)("li",{parentName:"ol"},"If the result of adding a new sample value to an existing sample\nvalue is either greater than 32,767 or less than -32,768 (these are\nthe maximum and minimum ",Object(r.b)("inlineCode",{parentName:"li"},"int16_t")," values, respectively), then your code\nshould clamp the result at 32,767 or -32,768.  (See the ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"#sound"}),"Sound"),"\nsection for details.)  To detect when a computed sample value is outside\nthe legal range, your code will need to do the addition using a data\ntype with a larger range of possible values (e.g., ",Object(r.b)("inlineCode",{parentName:"li"},"int32_t"),".)")),Object(r.b)("h2",{id:"the-render_tone-program"},"The ",Object(r.b)("inlineCode",{parentName:"h2"},"render_tone")," program"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"render_tone")," program renders a continuous tone with a specified\nvoice, frequency, amplitude, and duration.  This document describes the\nrequirements for the ",Object(r.b)("inlineCode",{parentName:"p"},"render_tone")," program.  This program will be a good\nway for you to validate the implementations of the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#wave-routines"}),"wave routines"),"."),Object(r.b)("h3",{id:"invocation-of-render_tone"},"Invocation of ",Object(r.b)("inlineCode",{parentName:"h3"},"render_tone")),Object(r.b)("p",null,"The program is invoked as"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"./render_tone voice frequency amplitude numsamples wavfileout\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"voice")," argument is an integer specifying the waveform shape to\ngenerate: 0 for sine wave, 1 for square wave, 2 for sawtooth wave.\n(See the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#wave-routines"}),"WAVE routines")," section for information about how\nto generate sine, square, and sawtooth waves.)"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"frequency")," argument is a floating-point value\nspecifying the frequency of the tone in Hz (cycles per second.)"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"amplitude")," argument is a floating-point value\nspecifying the relative amplitude of the tone, with 0.0 being complete\nsilence, to 1.0 being maximum volume."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"numsamples")," argument is the number of stereo samples\nto generate.  Because the sampling frequency is fixed at 44.1 KHz,\nthere are 44,100 stereo samples per second.  (Remember that a stereo\nsample consists of two signed 16-bit values, one for each audio channel.)"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"wavfileout")," argument specifies the name of the output\nWAVE file to generate."),Object(r.b)("h3",{id:"render_tone-examples"},Object(r.b)("inlineCode",{parentName:"h3"},"render_tone")," examples"),Object(r.b)("p",null,"Here are some examples of invoking the ",Object(r.b)("inlineCode",{parentName:"p"},"render_tone")," program and what\nthe resulting wave file should sound like."),Object(r.b)("p",null,"Rendering a 130.81 Hz sine wave:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"./render_tone 0 130.81 0.1 44100 c131_sine.wav\n")),Object(r.b)("p",null,"Resulting audio:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/c131_sine.wav",type:"audio/wav"})),Object(r.b)("p",null,"Rendering a 130.81 Hz square wave:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"./render_tone 1 130.81 0.1 44100 c131_sq.wav\n")),Object(r.b)("p",null,"Resulting audio:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/c131_sq.wav",type:"audio/wav"})),Object(r.b)("p",null,"Rendering a 130.81 Hz sawtooth wave:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-bash"}),"./render_tone 2 130.81 0.1 44100 c131_saw.wav\n")),Object(r.b)("p",null,"Resulting audio:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/c131_saw.wav",type:"audio/wav"})),Object(r.b)("div",null),Object(r.b)("h3",{id:"render_tone-approach"},Object(r.b)("inlineCode",{parentName:"h3"},"render_tone")," approach"),Object(r.b)("p",null,"First, the program should allocate an appropriately-sized mono sample buffer,\nand call either ",Object(r.b)("inlineCode",{parentName:"p"},"generate_sine_wave"),", ",Object(r.b)("inlineCode",{parentName:"p"},"generate_square_wave"),", or\n",Object(r.b)("inlineCode",{parentName:"p"},"generate_saw_wave")," to generate an appropriate waveform.  It should also\ncall the ",Object(r.b)("inlineCode",{parentName:"p"},"apply_gain")," function so that the waveform has the specified\namplitude."),Object(r.b)("p",null,"Next, the program should create a stereo sample array of an appropriate length\n(make sure the sample values are initially zero!), and call ",Object(r.b)("inlineCode",{parentName:"p"},"mix_in")," to\nincorporate the waveform into both the left and right channels."),Object(r.b)("p",null,"Finally, the program should open the output file, call the ",Object(r.b)("inlineCode",{parentName:"p"},"write_wave_header"),"\nfunction to write the WAVE header, then write the stereo sample data."),Object(r.b)("p",null,"Make sure that the program frees all allocated memory and closes any file\nthat was opened."),Object(r.b)("h2",{id:"the-render_song-program"},"The ",Object(r.b)("inlineCode",{parentName:"h2"},"render_song")," program"),Object(r.b)("p",null,"This document describes the ",Object(r.b)("inlineCode",{parentName:"p"},"render_song")," program."),Object(r.b)("h3",{id:"invocation-input-data-format"},"Invocation, input data format"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"render_song")," program, whose ",Object(r.b)("inlineCode",{parentName:"p"},"main")," function should be defined in\n",Object(r.b)("inlineCode",{parentName:"p"},"render_song.c"),", is invoked as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"./render_song songinput waveoutput\n")),Object(r.b)("p",null,"The file ",Object(r.b)("inlineCode",{parentName:"p"},"songinput"),' is a text file describing a "song".\nThe first value in a song file is the total number of samples.\nFor example, if this value is'),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"352800\n")),Object(r.b)("p",null,"then the song is 352,800 samples long.  With the fixed 44.1 KHz sample rate,\nthis means that the song is exactly 8 seconds long, and that one beat is exactly 0.5 seconds."),Object(r.b)("p",null,"Next, the song file will have a series of ",Object(r.b)("em",{parentName:"p"},"directives"),".  The following directives\nshould be supported:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"N instrument start end note gain"),": render a note using specified\ninstrument, starting at sample number ",Object(r.b)("inlineCode",{parentName:"li"},"start"),", ending just before sample\n",Object(r.b)("inlineCode",{parentName:"li"},"end"),", playing MIDI note number ",Object(r.b)("inlineCode",{parentName:"li"},"note"),", with specified ",Object(r.b)("inlineCode",{parentName:"li"},"gain")," factor"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"W instrument waveform"),": set the waveform of specified instrument, 0 for\nsine, 1 for square, 2 for sawtooth"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"P instrument angle"),": set the stereo pan angle (in radians) of specified instrument"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"E instrument enable"),": enable or disable ADSR envelope on specified instrument\n(0 to disable, 1 to enable)"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"G instrument gain"),": set the gain factor (0.0 to 1.0) of specified instrument")),Object(r.b)("p",null,"There are 16 instruments, numbered 0 through 15.  By default each instrument:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"Uses the sine waveform"),Object(r.b)("li",{parentName:"ul"},"Has its pan angle set to 0.0 (centered)"),Object(r.b)("li",{parentName:"ul"},"Has the ADSR envelope disabled"),Object(r.b)("li",{parentName:"ul"},"Has its gain set to 0.2")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"W"),", ",Object(r.b)("inlineCode",{parentName:"p"},"P"),", ",Object(r.b)("inlineCode",{parentName:"p"},"E"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"G")," directives modify the characteristics of a specified instrument."),Object(r.b)("p",null,"A ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://newt.phys.unsw.edu.au/jw/notes.html"}),"MIDI note number")," ",Object(r.b)("em",{parentName:"p"},"n")," can be converted to a frequency ",Object(r.b)("em",{parentName:"p"},"f")," using the following formula:"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"f")," = 440 ","\xd7"," 2",Object(r.b)("sup",null,"(",Object(r.b)("i",null,"n"),"-69) / 12")),Object(r.b)("h3",{id:"render_song-example"},Object(r.b)("inlineCode",{parentName:"h3"},"render_song")," example"),Object(r.b)("p",null,"Here is a fairly simple song:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"352800\n\nW 0 1\nE 0 1\nP 0 -0.4\n\nW 1 2\nE 1 1\nP 1 0.4\n\nN 0 0 8820 63 0.8\nN 0 0 8820 66 0.8\nN 1 22050 30870 61 0.8\nN 1 22050 30870 65 0.8\nN 0 44100 52920 63 0.8\nN 0 44100 52920 66 0.8\nN 1 66150 74970 61 0.8\nN 1 66150 74970 65 0.8\nN 0 88200 97020 63 0.8\nN 0 88200 97020 66 0.8\nN 1 110250 119070 61 0.8\nN 1 110250 119070 65 0.8\nN 0 132300 141120 63 0.8\nN 0 132300 141120 66 0.8\nN 1 154350 163170 61 0.8\nN 1 154350 163170 65 0.8\n\nN 0 176400 194040 66 0.8\nN 0 176400 194040 70 0.8\nN 1 220500 238140 66 0.8\nN 1 220500 238140 70 0.8\nN 0 264600 282240 66 0.8\nN 0 264600 282240 70 0.8\n")),Object(r.b)("p",null,"Note that there are two instruments, 0 and 1.  ADSR envelopes are enabled for\nboth instruments.  Instrument 0 plays notes using a square wave, and is panned\nat angle -0.4.  Instrument 1 plays notes using a sawtooth wave, and is panned\nat angle 0.4.  If we save this song in a file called ",Object(r.b)("inlineCode",{parentName:"p"},"example.txt"),", we can\nrender it as a wave file using the command"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"./render_song example.txt example.wav\n")),Object(r.b)("p",null,"The result sounds like this:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/example.wav",type:"audio/wav"})),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"TODO")," examples of more interesting songs"),Object(r.b)("h3",{id:"important-requirement"},"Important requirement"),Object(r.b)("p",null,"It is a requirement for this program that you use a ",Object(r.b)("inlineCode",{parentName:"p"},"struct")," data type to\nrepresent the information about each instrument.  Here is a possible\ndefinition:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"struct Instrument {\n  int waveform;\n  bool use_adsr_envelope;\n  float pan;\n  float gain;\n};\n")),Object(r.b)("p",null,"By declaring an array of elements of this type:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-c"}),"struct Instrument instruments[16];\n")),Object(r.b)("p",null,"you can represent all of the required information about each of the 16\npossible instruments."),Object(r.b)("h3",{id:"render_song-approach"},Object(r.b)("inlineCode",{parentName:"h3"},"render_song")," approach"),Object(r.b)("p",null,"The program should open the input text file and read the duration from it.\nIt can use the duration to create a stereo sample array of an appropriate\nlength."),Object(r.b)("p",null,"The program's main loop should read directives one at a time and process them."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"N"),"  directives can be carried out by calling ",Object(r.b)("inlineCode",{parentName:"p"},"generate_sine_wave"),",\n",Object(r.b)("inlineCode",{parentName:"p"},"generate_square_wave"),", or ",Object(r.b)("inlineCode",{parentName:"p"},"generate_saw_wave")," to render the note into\na mono sample buffer, calling ",Object(r.b)("inlineCode",{parentName:"p"},"apply_gain")," to scale the samples according\nto the instrument and note gain values, calling ",Object(r.b)("inlineCode",{parentName:"p"},"apply_adsr_envelope"),"\nif appropriate (depending on whether it is enabled for the instrument\nbeing played), calling ",Object(r.b)("inlineCode",{parentName:"p"},"compute_pan")," to compute the appopriate channel\ngain values according to the instruments pan angle, then incorporating\nthe mono sample values into each channel with the correct sample gain.\n(If you use the ",Object(r.b)("inlineCode",{parentName:"p"},"mix_in")," function to do this, you will probably need\nto allocate a separate mono sample buffer to hold the samples scaled\ncorrectly for the output channel.)"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"W"),", ",Object(r.b)("inlineCode",{parentName:"p"},"P"),", ",Object(r.b)("inlineCode",{parentName:"p"},"E"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"G")," directives should modified the appropriate instance\nof the struct type representing instruments."),Object(r.b)("p",null,"If, when attempting to read a directive character, the program encounters\nend of file, that means that the song has ended."),Object(r.b)("p",null,"If the input is malformed, the program should call the ",Object(r.b)("inlineCode",{parentName:"p"},"fatal_error")," function."),Object(r.b)("p",null,"Make sure that all memory is freed and file(s) closed before the program exits."),Object(r.b)("h2",{id:"the-render_echo-program"},"The ",Object(r.b)("inlineCode",{parentName:"h2"},"render_echo")," program"),Object(r.b)("p",null,"This section describes the requirements for the ",Object(r.b)("inlineCode",{parentName:"p"},"render_echo")," program."),Object(r.b)("h3",{id:"invocation"},"Invocation"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"render_echo")," program processes an input WAVE file to generate an echo effect, and is invoked as follows:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"./render_echo wavfilein wavfileout delay amplitude\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"wavfilein")," argument names an input WAVE file."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"wavfileout")," argument names an output WAVE file to write,\nwhich will be a transformed version of ",Object(r.b)("inlineCode",{parentName:"p"},"wavfilein"),"."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"delay")," argument is an integer delay, specified as a number of samples."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"amplitude")," argument is a floating point value in the range 0.0 to 1.0,\nspecifying a relative amplitude of the echo effect to generate."),Object(r.b)("h3",{id:"generating-an-echo"},"Generating an echo"),Object(r.b)("p",null,"Generating an echo is simple: the program should add an attenuated copy of\nthe audio signal at an offset as indicated by the ",Object(r.b)("inlineCode",{parentName:"p"},"delay"),"\nargument.  For example, if ",Object(r.b)("inlineCode",{parentName:"p"},"delay")," is 22050, that\nindicates a delay of 0.5 seconds.  The amplitude of the copied signal\nis specified by the ",Object(r.b)("inlineCode",{parentName:"p"},"amplitude")," argument.  For example,\nif ",Object(r.b)("inlineCode",{parentName:"p"},"amplitude")," is 0.4, then the echoed copy of the signal\nshould be 40% of the amplitude of the original."),Object(r.b)("p",null,"Note that the output will need to be ",Object(r.b)("inlineCode",{parentName:"p"},"delay")," number of samples longer than\nthe input, in order to ensure that echoes of samples at the end of the original\nfile are rendered."),Object(r.b)("h3",{id:"examples"},"Examples"),Object(r.b)("p",null,"As an example, let's say that ",Object(r.b)("inlineCode",{parentName:"p"},"example.wav")," is the original version of the\nexample song described in ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"#the-render_song-program"}),"the render","_","song program"),", and we run the command"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"./render_echo example.wav example_echo.wav 11025 0.4\n")),Object(r.b)("p",null,"Recall that the original sounded like this:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/example.wav",type:"audio/wav"})),Object(r.b)("p",null,"The result is this:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/example_echo.wav",type:"audio/wav"})),Object(r.b)("p",null,"The following (famous!) audio clip was used to test sound support early\nin the development of the Linux operating system:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/linux.wav",type:"audio/wav"})),Object(r.b)("p",null,"Assuming that this file is called ",Object(r.b)("inlineCode",{parentName:"p"},"linux.wav"),", we could add an echo with a 0.5\nsecond delay with the command:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"./render_echo linux.wav linux_echo.wav 22050 0.4\n")),Object(r.b)("p",null,"This yields the following result:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/linux_echo.wav",type:"audio/wav"})),Object(r.b)("p",null,"We can add an additional echo with a 0.25 second delay with the command:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"./render_echo linux_echo.wav linux_echo2.wav 11025 0.4\n")),Object(r.b)("p",null,"The result of this second command is the following:"),Object(r.b)("audio",{controls:!0},Object(r.b)("source",{src:"../../snd/linux_echo2.wav",type:"audio/wav"})),Object(r.b)("h3",{id:"render_echo-approach"},Object(r.b)("inlineCode",{parentName:"h3"},"render_echo")," approach"),Object(r.b)("p",null,"Your program will need to open the input file, call ",Object(r.b)("inlineCode",{parentName:"p"},"read_wave_header"),"\nto read the WAVE header and get the number of (stereo) samples, then read\nthe sample data into an array.  Adding the echo effect can be accomplished\nby adding attenuated sample values to the sample value at a later audio\nposition, effectively mixing the echo into the original audio.  Note that\nyou need to be careful about the order in which you process the samples!"),Object(r.b)("p",null,"Once the sample data has been updated, open the output file, call\n",Object(r.b)("inlineCode",{parentName:"p"},"write_wave_header")," to write the WAVE header, then write the updated\nsample values."),Object(r.b)("h2",{id:"testing"},"Testing"),Object(r.b)("p",null,"TODO: suggestions for testing"),Object(r.b)("h2",{id:"tips"},"Tips"),Object(r.b)("p",null,"TODO: tips and recommendations"),Object(r.b)("h2",{id:"packaging-requirements"},"Packaging requirements"),Object(r.b)("p",null,"TODO: how the makefile will need to work"))}p.isMDXComponent=!0}}]);